/* 
**  mod_log_sqlite.c -- Log to sqlite database 
**  [Autogenerated via ``apxs -n log_sqlite -g'']
**
**  Tatsuhiko Miyagawa <miyagawa@bulklnews.net>
**  IKEBE Tomohiro <ikechin@0xfa.com>
**
*/ 

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "http_log.h"
#include "http_core.h"
#include "ap_config.h"
#include "sqlite.h"

#define LOG_SQLITE_VERSION 0.06
#define SQL_TIMEOUT 30000

#define WATCHPOINT printf("WATCHPOINT %s %d\n", __FILE__, __LINE__)

#define LOG_SQLITE_CREATE "CREATE TABLE %s (" \
"    remote_host       varchar(50)," \
"    remote_user       varchar(50)," \
"    request_uri       varchar(50)," \
"    virtual_host      varchar(50)," \
"    time_stamp        integer unsigned not null," \
"    status            smallint(6)," \
"    bytes_sent        integer," \
"    referer           varchar(255)," \
"    agent             varchar(255)," \
"    request_method    varchar(6)," \
"    request_protocol  varchar(10)" \
")"

typedef struct {
  char *db_file;
  char *table;
  int auto_chown;
  sqlite *db;
} log_sqlite_config_rec;

module MODULE_VAR_EXPORT log_sqlite_module;

/* utility: NULL to "NULL", others escaped and quoted */
static char *quote(request_rec *r, const char *str)
{
  char *new;
  int  i, j, n;

  if (str == 0) {
    return "NULL";
  }

  for (i=0, n=0; str[i]; i++) {
    if (str[i] == '\'') n++;
  }
  n += i + 1;
  new = ap_palloc(r->pool, n + 2);

  new[0] = '\'';
  for (i=0, j=1; str[i]; i++) {
    new[j++] = str[i];
    if (str[i] == '\'') new[j++] = str[i];
  }
  new[i+1] = '\'';
  new[i+2] = 0;
  return new;
}

/* create config */
static void *create_log_sqlite_config(pool *p, server_rec *s)
{
  log_sqlite_config_rec *conf = (log_sqlite_config_rec *) ap_pcalloc(p, sizeof(log_sqlite_config_rec));
  conf->db_file = NULL;
  conf->table   = "access_log";
  conf->db      = 0;
  conf->auto_chown = 0;
  return (void *)conf;
}

/* set logdb file path */
static const char *set_sqlite_db_file(cmd_parms *cmd, void *mconfig, char *param)
{
  log_sqlite_config_rec *conf = (log_sqlite_config_rec *) ap_get_module_config(cmd->server->module_config, &log_sqlite_module);
  conf->db_file = param;

  return NULL;
}

/* set table name */
static const char *set_sqlite_table(cmd_parms *cmd, void *mconfig, char *param)
{
  log_sqlite_config_rec *conf = (log_sqlite_config_rec *) ap_get_module_config(cmd->server->module_config, &log_sqlite_module);
  conf->table = param;
  return NULL;
}

static const char *set_sqlite_auto_chown(cmd_parms *cmd, void *mconfig, int bool)
{
  log_sqlite_config_rec *conf = (log_sqlite_config_rec *) ap_get_module_config(cmd->server->module_config, &log_sqlite_module);
  conf->auto_chown = bool;
  return NULL;
}

static void log_sqlite_open(server_rec *s, pool *p)
{
    log_sqlite_config_rec *conf = (log_sqlite_config_rec *) ap_get_module_config(s->module_config, &log_sqlite_module);
    char *db_path;
    char *sqliteErr;
    int ret;
    char *log_dir;
    if (!conf->db_file) {
	return;
    }
    db_path  = ap_server_root_relative(p, conf->db_file);
    /* DEBUG */
    ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, s, 
		 "%s: db file %s", s->server_hostname, db_path);
    if (conf->auto_chown){
	log_dir = ap_make_dirstr_parent(p, db_path);
	ret = chown(log_dir, s->server_uid, s->server_gid);
	if (ret != 0)
	    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, s, "sqlite chown failed: %s", log_dir);
	ret = chown(db_path, s->server_uid, s->server_gid); 
	if (ret != 0)
	    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, s, "sqlite chown failed: %s", db_path);
    }

    conf->db = sqlite_open(db_path, 0600, &sqliteErr);
    if ((conf->db == 0) && sqliteErr) {
	ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, s, "sqlite open error: %s", sqliteErr);
	free(sqliteErr);
    }
    else {
	ret = sqlite_exec_printf(
	    conf->db,
	    LOG_SQLITE_CREATE,
	    NULL, NULL, &sqliteErr,
	    conf->table
	    );
	if (ret != SQLITE_OK){
	    ap_log_error(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, s, "sqlite exec error: %s", sqliteErr);
	    free(sqliteErr);
	}
    }
    return;
}

/* open logdb file */
static void init_log_sqlite(server_rec* s, pool *p)
{
    log_sqlite_open(s, p);
    for (s = s->next; s; s = s->next){
	log_sqlite_open(s, p);
    }
    return;
}

/* log_sqlite handler */
static int log_sqlite_handler(request_rec *r)
{
  log_sqlite_config_rec *conf = (log_sqlite_config_rec *) ap_get_module_config(r->server->module_config, &log_sqlite_module);
  char *sqliteErr;
  int  ret;

  if (conf->db == 0) {
    return DECLINED;
  }

  /* sets timeout handler */
  sqlite_busy_timeout(conf->db, SQL_TIMEOUT);
  
  /* using '%q' would lead to '(NULL)', thus I use my own quote() function */
  ret = sqlite_exec_printf(
    conf->db,
    "INSERT INTO %s
    (remote_host, remote_user, request_uri, virtual_host, time_stamp, status, bytes_sent, referer, agent, request_method, request_protocol)
    VALUES (%s,%s,%s,%s,%i,%i,%i,%s,%s,%s,%s)",
    NULL, NULL, &sqliteErr,
    conf->table,
    quote(r, ap_get_remote_host(r->connection, r->per_dir_config, REMOTE_NAME)),
    quote(r, r->connection->user),
    quote(r, r->uri),
    quote(r, r->hostname),
    r->request_time,
    r->status,
    r->bytes_sent,
    quote(r, ap_table_get(r->headers_in, "Referer")),
    quote(r, ap_table_get(r->headers_in, "User-Agent")),
    quote(r, r->method),
    quote(r, r->protocol)
    );
  

  if (ret != SQLITE_OK) {
    ap_log_rerror(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, r, "sqlite exec error: %s", sqliteErr);
    free(sqliteErr);
  }

  return OK;
}

static void log_sqlite_close(server_rec *s, pool *p)
{
    log_sqlite_config_rec *conf = (log_sqlite_config_rec *) ap_get_module_config(s->module_config, &log_sqlite_module);
    if (conf->db != 0)
	sqlite_close(conf->db);
    return;
}

/* close logdb on child exit */
static void cleanup_log_sqlite(server_rec *s, pool *p)
{
    log_sqlite_close(s, p);
    for (s = s->next; s; s = s->next){
	log_sqlite_close(s, p);
    }
    return;
}

/* setup commands */
static const command_rec log_sqlite_cmds[] = {
  {"LogSQLiteDBFile", set_sqlite_db_file, 
   NULL, RSRC_CONF, TAKE1, "sqlite log database file name"},
  {"LogSQLiteTable", set_sqlite_table, 
   NULL, RSRC_CONF, TAKE1, "sqlite log table name"},
  {"LogSQLiteAutoChown", set_sqlite_auto_chown, 
   NULL, RSRC_CONF, FLAG, "sqlite log file auto chown"},
  {NULL},
};

/* Dispatch list for API hooks */
module MODULE_VAR_EXPORT log_sqlite_module = {
    STANDARD_MODULE_STUFF, 
    init_log_sqlite,       /* module initializer                  */
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    create_log_sqlite_config,         /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    log_sqlite_cmds,       /* table of config file commands       */
    NULL,                  /* [#8] MIME-typed-dispatched handlers */
    NULL,                  /* [#1] URI to filename translation    */
    NULL,                  /* [#4] validate user id from request  */
    NULL,                  /* [#5] check if the user is ok _here_ */
    NULL,                  /* [#3] check access by host address   */
    NULL,                  /* [#6] determine MIME type            */
    NULL,                  /* [#7] pre-run fixups                 */
    log_sqlite_handler,    /* [#9] log a transaction              */
    NULL,                  /* [#2] header parser                  */
    NULL,                  /* child_init                          */
    cleanup_log_sqlite,    /* child_exit                          */
    NULL                   /* [#0] post read-request              */
};

